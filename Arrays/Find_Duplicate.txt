Given an array of integers nums containing n + 1 integers where each integer is in the 
range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and using only constant extra space.


⚡ Algorithm Recap
Treat the array as a linked list where i → nums[i].
Since numbers are in [1..n], following nums[i] always gives a valid index.
A duplicate number means there’s a cycle.
Phase 1: Detect cycle (slow = nums[slow], fast = nums[nums[fast]]).
Phase 2: Reset one pointer to start, move both one step → meeting point = duplicate.


// Optimized
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
       int slow=nums[0],fast=nums[0];

       do{
        slow=nums[slow];
        fast=nums[nums[fast]];
       } while(slow!=fast);

       fast=nums[0];
       while(slow!=fast){
        slow=nums[slow];
        fast=nums[fast];
       }
       return slow;
    }
};
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

 
 class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int num:nums){
            mp[num]++;
        }
        int n=nums.size();
        int k=n/3;
        vector<int> ans;
        for(auto it:mp){
            if(it.second>k){
                ans.push_back(it.first);
            }
        }
        return ans;
    }
}; 

class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int k = n / 3;
        vector<int> ans;

        for (int i = 0; i < n; ) {
            int j = i;
            // count frequency of nums[i]
            while (j < n && nums[j] == nums[i]) {
                j++;
            }
            int freq = j - i;
            if (freq > k) {
                ans.push_back(nums[i]);
            }
            i = j; // move to next distinct number
        }
        return ans;
    }
};


// Optimized Approach

class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        // Boyer–Moore Majority Vote
        int cand1=-1, cand2=-1;
        int cnt1=0,cnt2=0;

        int n=nums.size();
        for(int num:nums){
            if(cand1==num) cnt1++;
            else if(cand2==num) cnt2++;
            else if(cnt1==0) {cand1=num; cnt1=1;}
            else if(cnt2==0) {cand2=num; cnt2=1;}
            else {cnt1--; cnt2--;}
        }

        cnt1=0,cnt2=0;
        for(int num:nums){
            if(cand1==num) cnt1++;
            else if(cand2==num) cnt2++;

        }
        vector<int> ans;
        if (cnt1 > n/3) ans.push_back(cand1);
        if (cnt2 > n/3) ans.push_back(cand2);
        
        return ans;
    }
};